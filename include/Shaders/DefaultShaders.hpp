#pragma once
#ifndef _DEFAULT_SHADERS_H_
#define _DEFAULT_SHADERS_H_

#include <string>

class DefaultShaders {
 public:
  inline static const std::string VERT_SHADER =
      "#version 330\n"
      "\n"
      "layout(location = 0) in vec3 in_position;\n"
      "layout(location = 1) in vec3 in_color;\n"
      "layout(location = 2) in vec3 in_normal;\n"
      "layout(location = 3) in vec3 in_bary;\n"
      "layout(location = 4) in vec2 in_uv;\n"
      "layout(location = 5) in float in_id;\n"
      "\n"
      "uniform mat4 u_mvpMat;\n"
      "uniform mat4 u_mvMat;\n"
      "uniform mat4 u_normMat;\n"
      "uniform mat4 u_lightMat;\n"
      "uniform vec3 u_lightPos;\n"
      "\n"
      "out vec2 f_uv;\n"
      "out vec3 f_worldPos;\n"
      "out vec3 f_color;\n"
      "out vec3 f_normal;\n"
      "out vec3 f_barycentric;\n"
      "out float f_id;\n"
      "out vec3 f_positionCameraSpace;\n"
      "out vec3 f_normalCameraSpace;\n"
      "out vec3 f_lightPosCameraSpace;\n"
      "\n"
      "void main() {\n"
      "    gl_Position = u_mvpMat * vec4(in_position, 1.0);\n"
      "\n"
      "f_positionCameraSpace = (u_mvMat * vec4(in_position, 1.0)).xyz;\n"
      "f_normalCameraSpace = (u_normMat * vec4(in_normal, 0.0)).xyz;\n"
      "f_lightPosCameraSpace = (u_lightMat * vec4(u_lightPos, 1.0)).xyz;\n"
      "\n"
      "    f_worldPos = in_position;\n"
      "    f_color = in_color;\n"
      "    f_normal = in_normal;\n"
      "    f_barycentric = in_bary;\n"
      "    f_uv = in_uv;\n"
      "    f_id = in_id;\n"
      "}\n";

  inline static const std::string FRAG_SHADER =
      "#version 330\n"
      "\n"
      "in vec2 f_uv;\n"
      "in vec3 f_worldPos;\n"
      "in vec3 f_color;\n"
      "in vec3 f_normal;\n"
      "in vec3 f_barycentric;\n"
      "in float f_id;\n"
      "in vec3 f_positionCameraSpace;\n"
      "in vec3 f_normalCameraSpace;\n"
      "in vec3 f_lightPosCameraSpace;\n"
      "\n"
      "uniform float u_toUseTexture;\n"
      "uniform float u_wireFrameMode;\n"
      "uniform vec3 u_wireFrameColor;\n"
      "uniform float u_wireFrameWidth;\n"
      "uniform sampler2D u_texture;\n"
      "uniform float u_shininess;\n"
      "uniform float u_ambientIntensity;\n"
      "\n"
      "out vec4 out_color;\n"
      "\n"
      "void shading(\n"
      "    vec3 diffuseColor,\n"
      "    vec3 specularColor,\n"
      "    vec3 ambientColor\n"
      ") {\n"
      "    vec3 V = normalize(-f_positionCameraSpace);\n"
      "    vec3 L = normalize(f_lightPosCameraSpace - f_positionCameraSpace);\n"
      "    vec3 H = normalize(V + L);\n"
      "    vec3 N = normalize(f_normalCameraSpace);\n"
      "\n"
      "    float ndotl = max(0.0, dot(N, L));\n"
      "    float ndoth = max(0.0, dot(N, H));\n"
      "\n"
      "    vec3 diffuse = diffuseColor * ndotl;\n"
      "    vec3 specular = specularColor * pow(ndoth, u_shininess);\n"
      "    vec3 ambient = u_ambientIntensity * ambientColor;\n"
      "\n"
      "    out_color = vec4(diffuse + specular + ambient, 1.0);\n"
      "}\n"
      "\n"
      "void main() {\n"
      "    if(u_wireFrameMode > 0.5 && u_wireFrameMode < 1.5) {\n"
      "        // Wire frame\n"
      "        if(f_barycentric.x < u_wireFrameWidth || f_barycentric.y < u_wireFrameWidth || f_barycentric.z < u_wireFrameWidth) {\n"
      "            out_color = vec4(u_wireFrameColor, 1.0);\n"
      "            return;"
      "        }\n"
      "    } else if(u_wireFrameMode > -1.5 && u_wireFrameMode < -0.5) {\n"
      "        // Wire frame only\n"
      "        if(f_barycentric.x < u_wireFrameWidth || f_barycentric.y < u_wireFrameWidth || f_barycentric.z < u_wireFrameWidth) {\n"
      "            out_color = vec4(u_wireFrameColor, 1.0);\n"
      "        } else {\n"
      "            out_color = vec4(u_wireFrameColor, 0.0);\n"
      "        }\n"
      "        return;\n"
      "    }\n"
      "\n"
      "    if(u_toUseTexture > 2.5 && u_toUseTexture < 3.5) {\n"
      "        // Texture with shading\n"
      "        vec3 textureColor = texture(u_texture, f_uv).xyz;\n"
      "        shading(textureColor, vec3(1.0), textureColor);\n"
      "    } else if(u_toUseTexture > 1.5 && u_toUseTexture < 2.5) {\n"
      "        // Color with shading\n"
      "        shading(f_color, vec3(1.0), f_color);\n"
      "    } else if(u_toUseTexture > 0.5 && u_toUseTexture < 1.5) {\n"
      "        // Texture\n"
      "        out_color = texture(u_texture, f_uv);\n"
      "    } else if(u_toUseTexture > -0.5 && u_toUseTexture < 0.5) {\n"
      "        // Color\n"
      "        out_color = vec4(f_color, 1.0);\n"
      "    } else if(u_toUseTexture > -1.5 && u_toUseTexture < -0.5) {\n"
      "        // Face Normal\n"
      "        vec3 dfdx = dFdx(f_worldPos);\n"
      "        vec3 dfdy = dFdy(f_worldPos);\n"
      "        vec3 color = normalize(cross(dfdx, dfdy));\n"
      "        color = (color + 1.0) / 2.0;\n"
      "        out_color = vec4(color, 1.0);\n"
      "    } else if(u_toUseTexture > -2.5 && u_toUseTexture < -1.5) {\n"
      "        // Mask\n"
      "        out_color = vec4(1.0, 1.0, 1.0, 1.0);\n"
      "    } else if(u_toUseTexture > -3.5 && u_toUseTexture < -2.5) {\n"
      "        // Vertex normal\n"
      "        out_color = vec4(f_normal, 1.0);\n"
      "    }\n"
      "}\n";
};

#endif
